Mat temp = new Mat();
            threshold.CopyTo(temp);
            VectorOfVectorOfPoint contours = new VectorOfVectorOfPoint();
            Mat hierarchy = new Mat();
            
            CvInvoke.FindContours(temp, contours, hierarchy, Emgu.CV.CvEnum.RetrType.Ccomp, Emgu.CV.CvEnum.ChainApproxMethod.ChainApproxSimple);
            

           // CvInvoke.DrawContours(cameraFeed, contours, -1, new MCvScalar(0, 0, 255), 5); //nupiešia visus kontūrus, (-1 reiškia, kad peišti visus)

            Dictionary<int, double> dict = new Dictionary<int, double>();
            if (contours.Size > 0)
            {
                for (int i = 0; i < contours.Size; i++)
                {
                    double area = CvInvoke.ContourArea(contours[i]);
                    
                    dict.Add(i, area);
                }
            }

            var item = dict.OrderBy(v => v.Value);

            foreach (var it in item)
            {
                int key = int.Parse(it.Key.ToString());

                Rectangle rect = CvInvoke.BoundingRectangle(contours[key]);
                CvInvoke.Rectangle(cameraFeed, rect, new MCvScalar(0, 0, 255), 5);
                //CvInvoke.DrawContours(cameraFeed, contours, key, new MCvScalar(0, 0, 255), 5);
            }
